;;-*-Lisp-*-
(in-package goal)

(deftype lowreskui (process-drawable)
  ((root collide-shape-moving :override))
  (:state-methods idle)
  )

(def-art-elt lowreskui-ag lowreskui-lod0-jg 0)
(def-art-elt lowreskui-ag lowreskui-lod0-mg 1)
(def-art-elt lowreskui-ag lowreskui-idle-ja 2)

(defskelgroup *lowreskui-sg* lowreskui lowreskui-lod0-jg lowreskui-idle-ja
              ((lowreskui-lod0-mg (meters 9999999)))
              :bounds (static-spherem 0 0 0 4.5)
              :texture-level 2
              )

(defmethod init-from-entity! ((this lowreskui) (e entity-actor))
  (logior! (-> this mask) (process-mask enemy))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction)
          (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    ;; (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0))))
    ;;   (set! (-> mesh prim-core collide-as) (collide-kind enemy))
    ;;   (set! (-> mesh collide-with) (collide-kind target))
    ;;   (set! (-> mesh transform-index) 6)
    ;;   (set-vector! (-> mesh local-sphere) 0.0 0.0 0.0 (meters 4.5))
    ;;   (set-root-prim! cshape mesh)
    ;;   )
    (let ((sphere (new 'process 'collide-shape-prim-sphere cshape (the-as uint 3))))
      (set! (-> sphere prim-core collide-as) (collide-kind enemy))
      (set! (-> sphere collide-with) (collide-kind target))
      (set! (-> sphere prim-core action) (collide-action solid))
      (set! (-> sphere transform-index) 1)
      (set! (-> sphere prim-core offense) (collide-offense normal-attack))
      (set-vector! (-> sphere local-sphere) 0.0 0.0 0.0 (meters 2))
      (set-root-prim! cshape sphere)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape)
    )
  (process-drawable-from-entity! this e)
  (initialize-skeleton this *lowreskui-sg* '())
  ;; (set! (-> this draw shadow-ctrl)
  ;;       (new 'process 'shadow-control -5734.4 0.0 614400.0 (the-as float 1) 163840.0)
  ;;       )
  (logclear! (-> this mask) (process-mask actor-pause))
  (update-transforms! (-> this root))
  (go-virtual idle :proc this)
  (none)
  )

(defbehavior lowreskui-init-by-other lowreskui ((pos vector))
  (logior! (-> self mask) (process-mask enemy))
  (let ((cshape (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction)
          (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing)
          )
    ;; (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0))))
    ;;   (set! (-> mesh prim-core collide-as) (collide-kind enemy))
    ;;   (set! (-> mesh collide-with) (collide-kind target))
    ;;   (set! (-> mesh transform-index) 6)
    ;;   (set-vector! (-> mesh local-sphere) 0.0 0.0 0.0 (meters 4.5))
    ;;   (set-root-prim! cshape mesh)
    ;;   )
    (let ((sphere (new 'process 'collide-shape-prim-sphere cshape (the-as uint 1))))
      (set! (-> sphere prim-core collide-as) (collide-kind enemy))
      (set! (-> sphere collide-with) (collide-kind target))
      (set! (-> sphere prim-core action) (collide-action solid))
      (set! (-> sphere transform-index) 0)
      (set! (-> sphere prim-core offense) (collide-offense normal-attack))
      (set-vector! (-> sphere local-sphere) 0.0 0.0 0.0 (meters 2))
      (set-root-prim! cshape sphere)
      )
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> self root) cshape)
    )
  (initialize-skeleton self *lowreskui-sg* '())
  ;; (set! (-> self draw shadow-ctrl)
  ;;       (new 'process 'shadow-control -5734.4 0.0 614400.0 (the-as float 1) 163840.0)
  ;;       )
  (logclear! (-> self mask) (process-mask actor-pause))
  (update-transforms! (-> self root))
  (go-virtual idle)
  )

(defstate idle (lowreskui)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack 'touch)
       (if (= (-> proc type) target)
         (send-event proc 'attack #f (static-attack-info ((shove-up (meters 2.5)) (shove-back (meters 7.5)))))
         )
       )
      )
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    )
  :post transform-post
  )