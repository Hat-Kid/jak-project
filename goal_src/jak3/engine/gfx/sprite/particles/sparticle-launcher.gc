;;-*-Lisp-*-
(in-package goal)

;; name: sparticle-launcher.gc
;; name in dgo: sparticle-launcher
;; dgos: GAME

(defmacro launch-particles (&key (system *sp-particle-system-2d*)
                                 particle
                                 origin
                                 &key (launch-state (the-as sparticle-launch-state #f))
                                 &key (launch-control (the-as sparticle-launch-control #f))
                                 &key (rate 1.0)
                                 &key (origin-is-matrix #f))
  (if origin-is-matrix
      `(sp-launch-particles-var
         ,system
         ,particle
         (the matrix ,origin)
         ,launch-state
         ,launch-control
         ,rate #|(if (= (get-video-mode) 'custom) (/ (-> *display* time-factor) 5.0) ,rate)|#)
      `(begin
         (vector-copy! (-> *launch-matrix* trans) (the vector ,origin))
         (sp-launch-particles-var
            ,system
            ,particle
            *launch-matrix*
            ,launch-state
            ,launch-control
            ,rate #|(if (= (get-video-mode) 'custom) (/ (-> *display* time-factor) 5.0) ,rate)|#)
         )
      )
  )

(define-extern sparticle-2d-spline-align-instant (function object sparticle-cpuinfo sprite-vec-data-2d object none))
(define-extern rot-to-particle (function degrees sprite-vec-data-2d matrix none))

;; DECOMP BEGINS

;; WARN: Return type mismatch int vs sparticle-launcher.

(kmemopen global "part-tables")

(define *part-id-table* (new 'global 'boxed-array sparticle-launcher 5500))

(define *part-group-id-table* (new 'global 'boxed-array sparticle-launch-group 1700))

(define *sp-temp* 0.0)

(kmemclose)

(defun lookup-part-group-by-name ((arg0 string))
  (let* ((s5-0 *part-group-id-table*)
         (s4-0 (-> s5-0 length))
         )
    (dotimes (s3-0 s4-0)
      (let ((s2-0 (-> s5-0 s3-0)))
        (if (and (nonzero? s2-0) (string= arg0 (-> s2-0 name)))
            (return s2-0)
            )
        )
      )
    )
  (the-as sparticle-launch-group #f)
  )

;; WARN: Return type mismatch (pointer sparticle-launch-group) vs (pointer object).
(defun lookup-part-group-pointer-by-name ((arg0 string))
  (let* ((s4-0 *part-group-id-table*)
         (s3-0 (-> s4-0 length))
         )
    (dotimes (gp-0 s3-0)
      (let ((v1-2 (-> s4-0 gp-0)))
        (if (and (nonzero? v1-2) (string= arg0 (-> v1-2 name)))
            (return (the-as (pointer object) (&+ (-> s4-0 data) (* gp-0 4))))
            )
        )
      )
    )
  (the-as (pointer sparticle-launch-group) #f)
  )

(defun part-group-pointer? ((arg0 pointer))
  (let ((v1-0 *part-group-id-table*))
    (and (>= (the-as int arg0) (the-as int (-> v1-0 data))) (< (the-as int arg0) (the-as int (&-> v1-0 1700))))
    )
  )

(defun unlink-part-group-by-heap ((arg0 kheap))
  (let* ((v1-0 *part-group-id-table*)
         (a2-0 (-> v1-0 length))
         (a1-0 (-> arg0 base))
         (a0-1 (-> arg0 top-base))
         )
    (while (nonzero? a2-0)
      (+! a2-0 -1)
      (let ((a3-2 (-> v1-0 a2-0)))
        (when (and (>= (the-as int a3-2) (the-as int a1-0)) (< (the-as int a3-2) (the-as int a0-1)))
          (set! (-> v1-0 a2-0) (the-as sparticle-launch-group 0))
          0
          )
        )
      )
    )
  0
  )

(def-mips2c sp-init-fields! (function (pointer float) (inline-array sp-field-init-spec) sp-field-id sp-field-id symbol (inline-array sp-field-init-spec)))

(deftype sp-queued-launch-particles (structure)
  ((sp-system    sparticle-system)
   (sp-launcher  sparticle-launcher)
   (pos          vector  :inline)
   )
  )


(deftype sp-launch-queue (basic)
  ((in-use  int32)
   (queue   sp-queued-launch-particles  256 :inline)
   )
  )


(kmemopen global "launcher-queue")

(define *sp-launcher-lock* #f)

(define *sp-launch-queue* (new 'global 'sp-launch-queue))

(define *sp-launcher-enable* #t)

(kmemclose)

(defun particle-setup-adgif ((arg0 adgif-shader) (arg1 int))
  (let ((a1-1 (lookup-texture-by-id-fast (the-as texture-id arg1)))
        (s5-0 #f)
        )
    (when (not a1-1)
      (set! a1-1 (get-texture common-white common))
      (set! s5-0 #t)
      )
    (set! (-> arg0 tex1) (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
    (set! (-> arg0 tex0 tfx) 0)
    (adgif-shader<-texture! arg0 a1-1)
    (set! (-> arg0 prims 1) (gs-reg64 tex0-1))
    (set! (-> arg0 prims 3) (the-as gs-reg64 (logior arg1 20)))
    (set! (-> arg0 prims 5) (gs-reg64 miptbp1-1))
    (set! (-> arg0 clamp-reg) (gs-reg64 zbuf-1))
    (set! (-> arg0 prims 9) (gs-reg64 alpha-1))
    (if s5-0
        (logior! (-> arg0 link-test) (link-test-flags backup-sprite-tex))
        )
    )
  (set! (-> arg0 alpha) (new 'static 'gs-miptbp :tbp1 #x44))
  (set! (-> arg0 clamp) (new 'static 'gs-clamp :minu #x13 :minv #x101))
  0
  (none)
  )

(deftype particle-adgif-cache (basic)
  ((used     int32)
   (last     uint16)
   (lastgif  adgif-shader)
   (tidhash  uint16        80)
   (spadgif  adgif-shader  80 :inline)
   )
  )


(kmemopen global "part-adgif-cache")

(define *particle-adgif-cache* (new 'global 'particle-adgif-cache))

(set! (-> *particle-adgif-cache* used) 0)

(kmemclose)

(defun particle-adgif-cache-flush ()
  (set! (-> *particle-adgif-cache* used) 0)
  (set! (-> *particle-adgif-cache* last) (the-as uint 0))
  0
  (none)
  )

(def-mips2c particle-adgif (function adgif-shader texture-id none))

;; ERROR: Bad vector register dependency: vf16
;; ERROR: Bad vector register dependency: vf17
;; ERROR: Bad vector register dependency: vf18
;; ERROR: Bad vector register dependency: vf19
;; ERROR: Bad vector register dependency: vf20
(defun particle-adgif-callback ((arg0 adgif-shader) (arg1 texture-id))
  (local-vars (v1-0 float))
  (rlet ((vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf20 :class vf)
         )
    (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 4)))
      (let ((s4-0 (-> arg0 alpha))
            (s3-0 (-> arg0 clamp))
            )
        ;; og:preserve-this
        ; (.svf (&-> s5-0 0 quad) vf16)
        ; (.svf (&-> s5-0 1 quad) vf17)
        ; (.svf (&-> s5-0 2 quad) vf18)
        ; (.svf (&-> s5-0 3 quad) vf19)
        ; (.svf (&-> s5-0 4 quad) vf20)
        (particle-adgif arg0 arg1)
        (set! (-> arg0 alpha) s4-0)
        (set! (-> arg0 clamp) s3-0)
        )
      ;; og:preserve-this
      ; (.lvf vf16 (&-> s5-0 0 quad))
      ; (.lvf vf17 (&-> s5-0 1 quad))
      ; (.lvf vf18 (&-> s5-0 2 quad))
      ; (.lvf vf19 (&-> s5-0 3 quad))
      ; (.lvf vf20 (&-> s5-0 4 quad))
      )
    (.mov v1-0 vf20)
    0
    (none)
    )
  )

(defun sp-queue-launch ((arg0 sparticle-system) (arg1 sparticle-launcher) (arg2 matrix))
  (let ((v1-0 *sp-launch-queue*))
    (when (= (-> v1-0 in-use) 256)
      (format 0 "ERROR: sp-launch-particles called during processing, and queue is full~%")
      (return 0)
      )
    (let ((a3-5 (-> v1-0 queue (-> v1-0 in-use))))
      (set! (-> a3-5 sp-system) arg0)
      (set! (-> a3-5 sp-launcher) arg1)
      (set! (-> a3-5 pos quad) (-> arg2 trans quad))
      )
    (let ((v0-1 (+ (-> v1-0 in-use) 1)))
      (set! (-> v1-0 in-use) v0-1)
      v0-1
      )
    )
  )

(defun sp-adjust-launch ((arg0 sparticle-launchinfo)
                (arg1 sparticle-cpuinfo)
                (arg2 (inline-array sp-field-init-spec))
                (arg3 matrix)
                (arg4 symbol)
                )
  (let ((s2-0 (new 'stack-no-clear 'matrix))
        (s5-0 (new 'stack-no-clear 'matrix))
        )
    (let ((s0-0 (new 'stack-no-clear 'vector)))
      (sp-init-fields!
        (the-as (pointer float) (-> s2-0 rvec))
        arg2
        (sp-field-id launch-fields-start)
        (sp-field-id launch-fields-end)
        #t
        )
      (matrix-rotate-xyz! s5-0 (-> s2-0 rvec))
      (vector3s-matrix*! (the-as vector3s (-> arg1 vel-sxvel)) (the-as vector3s (-> arg1 vel-sxvel)) s5-0)
      (matrix-rotate-xyz! s5-0 (-> s2-0 uvec))
      (vector3s-matrix*! (the-as vector3s (-> arg1 vel-sxvel)) (the-as vector3s (-> arg1 vel-sxvel)) s5-0)
      (matrix*! s5-0 s5-0 arg3)
      (set-vector! s0-0 0.0 (-> s2-0 fvec w) 0.0 1.0)
      (vector-matrix*! s0-0 s0-0 s5-0)
      (+! (-> arg0 launchrot x) (-> s0-0 x))
      (+! (-> arg0 launchrot y) (-> s0-0 y))
      (+! (-> arg0 launchrot z) (-> s0-0 z))
      )
    (when (logtest? (sp-cpuinfo-flag set-conerot) (-> arg1 flags))
      (let ((f0-10 (vector-length (-> arg3 rvec)))
            (f1-3 (vector-length (-> arg3 uvec)))
            (f2-0 (vector-length (-> arg3 fvec)))
            )
        (set! (-> arg0 launchrot w) (* (-> arg0 launchrot w) f0-10))
        (set! (-> arg0 conerot w) (* (-> arg0 conerot w) f1-3))
        (set! (-> arg1 vel-sxvel w) (* (-> arg1 vel-sxvel w) f0-10))
        (set! (-> arg1 rot-syvel w) (* (-> arg1 rot-syvel w) f1-3))
        (set! (-> arg1 vel-sxvel x) (* (-> arg1 vel-sxvel x) f0-10))
        (set! (-> arg1 vel-sxvel y) (* (-> arg1 vel-sxvel y) f1-3))
        (set! (-> arg1 vel-sxvel z) (* (-> arg1 vel-sxvel z) f2-0))
        )
      )
    (matrix-rotate-xyz! s5-0 (-> s2-0 fvec))
    (matrix*! s5-0 s5-0 arg3)
    (vector3s-rotate*! (the-as vector3s (-> arg0 launchrot)) (the-as vector3s (-> arg0 launchrot)) s5-0)
    (vector3s-rotate*! (the-as vector3s (-> arg1 vel-sxvel)) (the-as vector3s (-> arg1 vel-sxvel)) s5-0)
    (if (not (logtest? (sp-cpuinfo-flag launch-along-z) (-> arg1 flags)))
        (vector3s-rotate*! (the-as vector3s (-> arg1 acc)) (the-as vector3s (-> arg1 acc)) s5-0)
        )
    (if (logtest? (sp-cpuinfo-flag right-multiply-quat) (-> arg1 flags))
        (set! (-> arg0 conerot y) (+ 16384.0 (vector-y-angle (-> s5-0 fvec))))
        )
    (when arg4
      (let ((s4-1 (new 'stack-no-clear 'euler-angles)))
        (matrix->eul s4-1 s5-0 13)
        (set! (-> arg0 conerot x) (- (-> arg0 conerot x) (-> s4-1 y)))
        (set! (-> arg0 conerot y) (- (-> arg0 conerot y) (-> s4-1 z)))
        (set! (-> arg0 conerot z) (- (-> arg0 conerot z) (-> s4-1 x)))
        )
      )
    )
  0
  (none)
  )

(defun sp-euler-convert ((arg0 sparticle-launchinfo) (arg1 sparticle-cpuinfo))
  (local-vars (v1-1 float) (v1-2 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'quaternion))
          )
      (set-vector! a1-1 (-> arg0 conerot x) (-> arg0 conerot y) (-> arg0 conerot z) 1.0)
      (quaternion-zxy! s5-0 a1-1)
      (cond
        ((< (-> s5-0 w) 0.0)
         (.lvf vf1 (&-> arg0 conerot quad))
         (.lvf vf2 (&-> s5-0 quad))
         (.sub.vf vf1 vf0 vf2 :mask #b111)
         (.svf (&-> arg0 conerot quad) vf1)
         (.mov v1-1 vf1)
         )
        (else
          (.lvf vf1 (&-> arg0 conerot quad))
          (.lvf vf2 (&-> s5-0 quad))
          (.add.vf vf1 vf0 vf2 :mask #b111)
          (.svf (&-> arg0 conerot quad) vf1)
          (.mov v1-2 vf1)
          )
        )
      )
    (cond
      (*sp-60-hz*
        (set! (-> arg1 rot-syvel x) (* 5.0 (-> arg1 rot-syvel x)))
        (set! (-> arg1 rot-syvel y) (* 5.0 (-> arg1 rot-syvel y)))
        (set! (-> arg1 rot-syvel z) (* 5.0 (-> arg1 rot-syvel z)))
        )
      (else
        (set! (-> arg1 rot-syvel x) (* 6.0 (-> arg1 rot-syvel x)))
        (set! (-> arg1 rot-syvel y) (* 6.0 (-> arg1 rot-syvel y)))
        (set! (-> arg1 rot-syvel z) (* 6.0 (-> arg1 rot-syvel z)))
        )
      )
    (quaternion-zxy! (-> arg1 rotvel3d) (-> arg1 rot-syvel))
    0
    (none)
    )
  )

(defun sp-rotate-system ((arg0 sparticle-launchinfo) (arg1 sparticle-cpuinfo) (arg2 transformq))
  (let ((s5-0 (new 'stack-no-clear 'matrix)))
    (let ((a1-1 (new 'stack-no-clear 'quaternion)))
      (let* ((v1-0 a1-1)
             (a0-1 arg2)
             (f0-0 (-> a0-1 quat x))
             (f1-0 (-> a0-1 quat y))
             (f2-0 (-> a0-1 quat z))
             )
        (set! (-> v1-0 x) f0-0)
        (set! (-> v1-0 y) f1-0)
        (set! (-> v1-0 z) f2-0)
        (set! (-> v1-0 w) (sqrtf (- (- (- 1.0 (* f2-0 f2-0)) (* f1-0 f1-0)) (* f0-0 f0-0))))
        )
      (quaternion->matrix s5-0 a1-1)
      )
    (vector3s-rotate*! (the-as vector3s (-> arg0 launchrot)) (the-as vector3s (-> arg0 launchrot)) s5-0)
    (vector3s-rotate*! (the-as vector3s (-> arg1 vel-sxvel)) (the-as vector3s (-> arg1 vel-sxvel)) s5-0)
    (if (not (logtest? (sp-cpuinfo-flag launch-along-z) (-> arg1 flags)))
        (vector3s-rotate*! (the-as vector3s (-> arg1 acc)) (the-as vector3s (-> arg1 acc)) s5-0)
        )
    )
  0
  (none)
  )

(deftype sp-launch-stack (structure)
  ((ra          basic)
   (dummy0      basic)
   (dummy1      basic)
   (b-spfic     basic)
   (r16         uint128)
   (r17         uint128)
   (r18         uint128)
   (pos         uint128)
   (matrix      matrix               :inline)
   (l-spfic     basic)
   (birth-info  sparticle-birthinfo  :inline)
   (sprite      sprite-vec-data-2d   :inline)
   (r19         uint128)
   (r20         uint128)
   (r21         uint128)
   (r22         uint128)
   )
  )


(def-mips2c sp-launch-particles-var (function sparticle-system sparticle-launcher matrix sparticle-launch-state sparticle-launch-control float none))

;; (defun sp-launch-particles-var ((a sparticle-system) (b sparticle-launcher) (c matrix) (d sparticle-launch-state) (e sparticle-launch-control) (f float))
;;   (none)
;;   )

(define *death-adgif* (the-as adgif-shader #f))

;; WARN: Function sp-launch-particles-death has a return type of none, but the expression builder found a return statement.
(defun sp-launch-particles-death ((arg0 sparticle-system) (arg1 sparticle-launcher) (arg2 vector))
  (local-vars (v1-26 float) (v1-28 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf30 (&-> arg2 quad))
    (let ((v1-0 #x437f0000))
      (.mov vf31 v1-0)
      )
    (let ((s5-0 (new 'stack-no-clear 'matrix))
          (gp-0 (sp-get-particle arg0 0 (the-as sparticle-launch-state #f)))
          )
      (if (not gp-0)
          (return 0)
          )
      (let* ((a1-2 (-> arg1 init-specs 0))
             (a1-3 (sp-init-fields!
                     (the-as (pointer float) (-> s5-0 rvec))
                     (the-as (inline-array sp-field-init-spec) a1-2)
                     (sp-field-id sprite-fields-start)
                     (sp-field-id sprite-fields-end)
                     #t
                     )
                   )
             )
        (sp-init-fields! (&-> gp-0 omega) a1-3 (sp-field-id cpu-fields-start) (sp-field-id cpu-fields-end) #t)
        )
      (set! (-> s5-0 uvec y) 0.0)
      (set! (-> s5-0 uvec z) (the float (sar (shl (the int (-> s5-0 uvec z)) 48) 48)))
      (.lvf vf4 (&-> s5-0 fvec quad))
      (.lvf vf5 (&-> s5-0 rvec quad))
      (.min.x.vf vf4 vf4 vf31 :mask #b111)
      (.add.vf vf5 vf5 vf30 :mask #b111)
      (.svf (&-> s5-0 fvec quad) vf4)
      (.svf (&-> s5-0 rvec quad) vf5)
      (when (not *death-adgif*)
        (set! *death-adgif* (new 'static 'adgif-shader))
        (particle-adgif *death-adgif* (new 'static 'texture-id :index #x18 :page #x4))
        (set! (-> *death-adgif* alpha) (new 'static 'gs-miptbp :tbp1 #x48))
        )
      (let ((v1-14 (-> *death-adgif* quad 0 quad)))
        (set! (-> gp-0 adgif quad 0 quad) v1-14)
        )
      (let ((v1-16 (-> *death-adgif* quad 1 quad)))
        (set! (-> gp-0 adgif quad 1 quad) v1-16)
        )
      (let ((v1-18 (-> *death-adgif* quad 2 quad)))
        (set! (-> gp-0 adgif quad 2 quad) v1-18)
        )
      (let ((v1-20 (-> *death-adgif* quad 3 quad)))
        (set! (-> gp-0 adgif quad 3 quad) v1-20)
        )
      (let ((v1-22 (-> *death-adgif* quad 4 quad)))
        (set! (-> gp-0 adgif quad 4 quad) v1-22)
        )
      (set! (-> gp-0 clock-index) (the-as uint 8))
      (.lvf vf4 (&-> (-> *time-of-day-context* current-prt-color) quad))
      (.lvf vf5 (&-> s5-0 fvec quad))
      (.lvf vf6 (&-> gp-0 fade quad))
      (.mul.vf vf5 vf5 vf4 :mask #b111)
      (.mul.vf vf6 vf6 vf4 :mask #b111)
      (.svf (&-> s5-0 fvec quad) vf5)
      (.svf (&-> gp-0 fade quad) vf6)
      (.mov v1-26 vf6)
      (set! (-> gp-0 key) (the-as sparticle-launch-control 0))
      (set! (-> gp-0 binding) #f)
      (let ((v1-27 (-> gp-0 sprite)))
        (.lvf vf1 (&-> s5-0 rvec quad))
        (.lvf vf2 (&-> s5-0 uvec quad))
        (.lvf vf3 (&-> s5-0 fvec quad))
        (.svf (&-> v1-27 x-y-z-sx quad) vf1)
        (.svf (&-> v1-27 flag-rot-sy quad) vf2)
        (.sub.w.vf vf3 vf0 vf0 :mask #b1000)
        (.svf (&-> v1-27 r-g-b-a quad) vf3)
        )
      (.mov v1-28 vf3)
      (logior! (-> gp-0 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-5))
      (set! (-> gp-0 cache-alpha) (-> s5-0 fvec w))
      )
    0
    (none)
    )
  )

(defun sp-clear-queue ()
  (let ((gp-0 *sp-launch-queue*)
        (s5-0 *launch-matrix*)
        )
    (when (> (-> gp-0 in-use) 0)
      (dotimes (s4-0 (-> gp-0 in-use))
        (let ((v1-4 (-> gp-0 queue s4-0)))
          (set! (-> s5-0 trans quad) (-> v1-4 pos quad))
          (launch-particles :system (-> v1-4 sp-system) (-> v1-4 sp-launcher) s5-0 :origin-is-matrix #t)
          )
        )
      (set! (-> gp-0 in-use) 0)
      0
      )
    )
  0
  (none)
  )

(defun sp-relaunch-setup-fields ((arg0 object) (arg1 sparticle-launcher) (arg2 sparticle-cpuinfo) (arg3 sprite-vec-data-3d))
  (local-vars
    (sv-80 (inline-array sp-field-init-spec))
    (sv-88 sp-cpuinfo-flag)
    (sv-96 matrix)
    (sv-100 symbol)
    (sv-104 symbol)
    )
  (set! sv-80 (the-as (inline-array sp-field-init-spec) (-> arg1 init-specs 0)))
  (set! sv-88 (logand (-> arg2 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-9 level0 level1 sp-cpuinfo-flag-12)))
  (set! sv-96 (new 'stack-no-clear 'matrix))
  (set! sv-100 (the-as symbol #f))
  (set! sv-104 (the-as symbol #f))
  (set! (-> arg2 next-launcher) (the-as basic 0))
  (when (nonzero? (-> arg2 key))
    (let ((s3-0 #t))
      (cond
        ((logtest? (sp-cpuinfo-flag left-multiply-quat) (-> arg2 flags))
         (quaternion->matrix sv-96 (-> arg2 key proc root quat))
         )
        ((logtest? (-> arg2 key group flags) (sp-group-flag sp12))
         (let* ((v1-17 sv-96)
                (a3-1 (-> arg2 key local-space-binding mat-new))
                (a0-5 (-> a3-1 rvec quad))
                (a1-2 (-> a3-1 uvec quad))
                (a2-1 (-> a3-1 fvec quad))
                (a3-2 (-> a3-1 trans quad))
                )
           (set! (-> v1-17 rvec quad) a0-5)
           (set! (-> v1-17 uvec quad) a1-2)
           (set! (-> v1-17 fvec quad) a2-1)
           (set! (-> v1-17 trans quad) a3-2)
           )
         )
        (else
          (set! s3-0 #f)
          )
        )
      (when s3-0
        (matrix-transpose! sv-96 sv-96)
        (when (or (get-field-spec-by-id arg1 (sp-field-id spt-accel-x))
                  (get-field-spec-by-id arg1 (sp-field-id spt-accel-y))
                  (get-field-spec-by-id arg1 (sp-field-id spt-accel-z))
                  )
          (set! sv-100 #t)
          (vector3s-rotate*! (the-as vector3s (-> arg2 acc)) (the-as vector3s (-> arg2 acc)) sv-96)
          )
        (when (or (get-field-spec-by-id arg1 (sp-field-id spt-vel-x))
                  (get-field-spec-by-id arg1 (sp-field-id spt-vel-y))
                  (get-field-spec-by-id arg1 (sp-field-id spt-vel-z))
                  )
          (set! sv-104 #t)
          (vector3s-rotate*! (the-as vector3s (-> arg2 vel-sxvel)) (the-as vector3s (-> arg2 vel-sxvel)) sv-96)
          )
        (matrix-transpose! sv-96 sv-96)
        )
      )
    )
  (cond
    ((and (logtest? (-> arg2 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-13))
          (not (logtest? (-> arg2 flags) (sp-cpuinfo-flag distort)))
          (not (logtest? (-> arg2 flags) (sp-cpuinfo-flag glow)))
          )
     (let ((f20-0 (-> arg3 r-g-b-a x))
           (f22-0 (-> arg3 r-g-b-a y))
           (f24-0 (-> arg3 r-g-b-a z))
           (f26-0 (-> arg2 fade x))
           (f28-0 (-> arg2 fade y))
           (f30-0 (-> arg2 fade z))
           )
       (set! (-> arg3 r-g-b-a x) 99999.0)
       (set! (-> arg3 r-g-b-a y) 99999.0)
       (set! (-> arg3 r-g-b-a z) 99999.0)
       (set! (-> arg2 fade x) 99999.0)
       (set! (-> arg2 fade y) 99999.0)
       (set! (-> arg2 fade z) 99999.0)
       (set! sv-80
             (sp-init-fields!
               (the-as (pointer float) (-> arg3 x-y-z-sx))
               sv-80
               (sp-field-id sprite-fields-start)
               (sp-field-id sprite-fields-end)
               #f
               )
             )
       (set! sv-80
             (sp-init-fields! (&-> arg2 omega) sv-80 (sp-field-id cpu-fields-start) (sp-field-id cpu-fields-end) #f)
             )
       (logior! (-> arg2 flags) sv-88)
       (let ((v1-54 (-> *time-of-day-context* current-prt-color)))
         (if (= (-> arg3 r-g-b-a x) 99999.0)
             (set! (-> arg3 r-g-b-a x) f20-0)
             (set! (-> arg3 r-g-b-a x) (* (-> arg3 r-g-b-a x) (-> v1-54 x)))
             )
         (if (= (-> arg3 r-g-b-a y) 99999.0)
             (set! (-> arg3 r-g-b-a y) f22-0)
             (set! (-> arg3 r-g-b-a y) (* (-> arg3 r-g-b-a y) (-> v1-54 y)))
             )
         (if (= (-> arg3 r-g-b-a z) 99999.0)
             (set! (-> arg3 r-g-b-a z) f24-0)
             (set! (-> arg3 r-g-b-a z) (* (-> arg3 r-g-b-a z) (-> v1-54 z)))
             )
         (if (= (-> arg2 fade x) 99999.0)
             (set! (-> arg2 fade x) f26-0)
             (set! (-> arg2 fade x) (* (-> arg2 fade x) (-> v1-54 x)))
             )
         (if (= (-> arg2 fade y) 99999.0)
             (set! (-> arg2 fade y) f28-0)
             (set! (-> arg2 fade y) (* (-> arg2 fade y) (-> v1-54 y)))
             )
         (if (= (-> arg2 fade z) 99999.0)
             (set! (-> arg2 fade z) f30-0)
             (set! (-> arg2 fade z) (* (-> arg2 fade z) (-> v1-54 z)))
             )
         )
       )
     )
    (else
      (set! sv-80
            (sp-init-fields!
              (the-as (pointer float) (-> arg3 x-y-z-sx))
              sv-80
              (sp-field-id sprite-fields-start)
              (sp-field-id sprite-fields-end)
              #f
              )
            )
      (set! sv-80
            (sp-init-fields! (&-> arg2 omega) sv-80 (sp-field-id cpu-fields-start) (sp-field-id cpu-fields-end) #f)
            )
      )
    )
  (if sv-100
      (vector3s-rotate*! (the-as vector3s (-> arg2 acc)) (the-as vector3s (-> arg2 acc)) sv-96)
      )
  (if sv-104
      (vector3s-rotate*! (the-as vector3s (-> arg2 vel-sxvel)) (the-as vector3s (-> arg2 vel-sxvel)) sv-96)
      )
  0
  0
  (none)
  )

(defun sp-relaunch-particle-2d ((arg0 object) (arg1 sparticle-launcher) (arg2 sparticle-cpuinfo) (arg3 sprite-vec-data-2d))
  (sp-relaunch-setup-fields arg0 arg1 arg2 (the-as sprite-vec-data-3d arg3))
  (when (logtest? (-> arg2 flags) (sp-cpuinfo-flag distort))
    (set! (-> arg3 r-g-b-a w) 0.0)
    (set! (-> arg2 fade w) 0.0)
    (logclear! (-> arg2 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-2))
    )
  (when (logtest? (-> arg2 flags) (sp-cpuinfo-flag glow))
    )
  0
  (none)
  )

(defmethod create-launch-control ((this sparticle-launch-group) (arg0 process))
  (the sparticle-launch-control #f)
  )

(defun sp-launch-particles-var ((arg0 sparticle-system)
                                (arg1 sparticle-launcher)
                                (arg2 matrix)
                                (arg3 sparticle-launch-state)
                                (arg4 sparticle-launch-control)
                                (arg5 float)
                                )
  (none)
  )

(defun lookup-part-group-by-name ((arg0 string))
  (the sparticle-launch-group #f)
  )

;; WARN: Return type mismatch (pointer sparticle-launch-group) vs (pointer object).
(defun lookup-part-group-pointer-by-name ((arg0 string))
  (the (pointer sparticle-launch-group) #f)
  )

(defun part-group-pointer? ((arg0 pointer))
  #f
  )